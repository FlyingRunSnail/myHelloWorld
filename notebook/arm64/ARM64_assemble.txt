1、基本寄存器
   x0-x30  64位  通用寄存器，也可以当做32位寄存器使用，w0-w30
       x0-x7:    用于子程序调用时传递参数，x0还用于返回值传递
       w0-w30:   对应x0-x30的低32位
   FP(x29) 64位  栈帧寄存器，保存栈底指针
   LR(x30) 64位  链接寄存器，保存下一条要执行的指令
   SP      64位  栈指针寄存器
   PC      64位  程序计数器，总是指向即将要执行的下一条指令
   CPSR    64位  状态寄存器 



2、基本汇编指令
   MOV    X1，X0         ;将寄存器X0的值传送到寄存器X1
   ADD    X0，X1，X2     ;寄存器X1和X2的值相加后传送到X0
   SUB    X0，X1，X2     ;寄存器X1和X2的值相减后传送到X0
   AND    X0，X0，#0xF    ; X0的值与0xF相位与后的值传送到X0
   ORR    X0，X0，#9      ; X0的值与9相位或后的值传送到X0
   EOR    X0，X0，#0xF    ; X0的值与0xF相异或后的值传送到X0
   LDR    X5，[X6，#0x08]        ；X6寄存器加0x08的和的地址值内的数据传送到X5
   STR X0, [SP, #0x8]         ；X0寄存器的数据传送到SP+0x8地址值指向的存储空间
   STP  x29, x30, [sp, #0x10]    ;入栈指令
   LDP  x29, x30, [sp, #0x10]    ;出栈指令
   CBZ  ;比较（Compare），如果结果为零（Zero）就转移（只能跳到后面的指令）
   CBNZ ;比较，如果结果非零（Non Zero）就转移（只能跳到后面的指令）
   CMP  ;比较指令，相当于SUBS，影响程序状态寄存器CPSR 
   B/BL  ;绝对跳转#imm， 返回地址保存到LR（X30）
   RET   ;子程序返回指令，返回地址默认保存在LR（X30）


3、X29永远指向当前函数调用栈的FP,上一个调用栈的FP为*FP，以此递归可以获取整个调用栈
   LR指向当前函数返回后即执行的地址，也就是调用该函数前的下一条地址
   在ARM64中，按照APCS64，永远是先入栈LR，紧接着入栈FP，由于ARM64栈是从高向低增长，
   因此FP+8即是LR的地址，LR-4即是PC的地址
   基于FP的获取规则和LR（PC）即可对整个调用栈进行展开，结合符号查询工具即可进行栈回溯
                           +------------+
                           |____________|
                           |____________|
     +----------------+    |____________|
     |      x29       |--->|____________|
     +----------------+    |____________|
                           |____________|
                           |            |
                           +------------+

     reference:https://www.cnblogs.com/coder51up/p/6940030.html
